{
  "DSU": {
    "prefix": "DSU",
    "body": [
      "#[derive(Debug, Clone)]",
      "struct DSU {",
      "    parent: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    components: usize,",
      "}",
      "impl DSU {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            parent: (0..n).collect(),",
      "            rank: vec![1; n],",
      "            components: n,",
      "        }",
      "    }",
      "    pub fn from<T>(adj: &Vec<T>) -> Self",
      "    where",
      "        for<'a> &'a T: IntoIterator<Item = &'a usize>,",
      "    {",
      "        let n = adj.len();",
      "        let mut dsu = DSU::new(n);",
      "        for u in 0..n {",
      "            for &v in adj[u].into_iter() {",
      "                dsu.unite(u, v);",
      "            }",
      "        }",
      "        dsu",
      "    }",
      "    pub fn find(&mut self, v: usize) -> usize {",
      "        if self.parent[v] == v {",
      "            return v;",
      "        }",
      "        let parent = self.find(self.parent[v]);",
      "        self.parent[v] = parent;",
      "        parent",
      "    }",
      "    pub fn unite(&mut self, a: usize, b: usize) {",
      "        let mut par_a = self.find(a);",
      "        let mut par_b = self.find(b);",
      "        if par_a != par_b {",
      "            if self.rank[par_a] < self.rank[par_b] {",
      "                std::mem::swap(&mut par_a, &mut par_b);",
      "            }",
      "            self.parent[par_b] = par_a;",
      "            self.rank[par_a] += self.rank[par_b];",
      "            self.components -= 1;",
      "        }",
      "    }",
      "}"
    ]
  },
  "DefaultMap": {
    "prefix": "DefaultMap",
    "body": [
      "struct DefaultMap<K, V> {",
      "    pub map: std::collections::BTreeMap<K, V>,",
      "}",
      "impl<K: Ord, V: Default> DefaultMap<K, V> {",
      "    pub fn new() -> DefaultMap<K, V> {",
      "        DefaultMap {",
      "            map: std::collections::BTreeMap::new(),",
      "        }",
      "    }",
      "    pub fn iter(&self) -> std::collections::btree_map::Iter<K, V> {",
      "        self.map.iter()",
      "    }",
      "}",
      "impl<K: Ord + Clone, V: Default> std::ops::IndexMut<K> for DefaultMap<K, V> {",
      "    fn index_mut(&mut self, key: K) -> &mut Self::Output {",
      "        self.map.entry(key).or_insert(V::default())",
      "    }",
      "}",
      "impl<K: Ord + Clone, V: Default> std::ops::Index<K> for DefaultMap<K, V> {",
      "    type Output = V;",
      "    fn index(&self, key: K) -> &Self::Output {",
      "        self.map.get(&key).unwrap()",
      "    }",
      "}"
    ]
  },
  "ModInt": {
    "prefix": "ModInt",
    "body": [
      "trait Modulus {",
      "    const VALUE: usize;",
      "}",
      "#[derive(Copy, Clone, Debug, Hash, Ord, PartialOrd, Eq, PartialEq)]",
      "struct ModInt<M: Modulus + Copy> {",
      "    value: usize,",
      "    _phantom: std::marker::PhantomData<M>,",
      "}",
      "impl<M: Modulus + Copy> ModInt<M> {",
      "    pub fn new(value: usize) -> Self {",
      "        Self {",
      "            value: value.rem_euclid(M::VALUE),",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "    pub fn one() -> Self {",
      "        Self {",
      "            value: 1,",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "    pub fn zero() -> Self {",
      "        Self {",
      "            value: 0,",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::AddAssign for ModInt<M> {",
      "    fn add_assign(&mut self, other: ModInt<M>) {",
      "        self.value = (self.value + other.value).rem_euclid(M::VALUE);",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::Add for ModInt<M> {",
      "    type Output = ModInt<M>;",
      "    fn add(self, other: ModInt<M>) -> Self::Output {",
      "        Self {",
      "            value: (self.value + other.value).rem_euclid(M::VALUE),",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::SubAssign for ModInt<M> {",
      "    fn sub_assign(&mut self, other: ModInt<M>) {",
      "        self.value = (self.value + M::VALUE - other.value).rem_euclid(M::VALUE);",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::Sub for ModInt<M> {",
      "    type Output = ModInt<M>;",
      "    fn sub(self, other: ModInt<M>) -> Self::Output {",
      "        Self {",
      "            value: (self.value + M::VALUE - other.value).rem_euclid(M::VALUE),",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::MulAssign for ModInt<M> {",
      "    fn mul_assign(&mut self, other: ModInt<M>) {",
      "        self.value = (self.value * other.value).rem_euclid(M::VALUE);",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::Mul for ModInt<M> {",
      "    type Output = ModInt<M>;",
      "    fn mul(self, other: ModInt<M>) -> Self::Output {",
      "        Self {",
      "            value: (self.value * other.value).rem_euclid(M::VALUE),",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus + Copy> From<usize> for ModInt<M> {",
      "    fn from(value: usize) -> Self {",
      "        Self {",
      "            value: value.rem_euclid(M::VALUE),",
      "            _phantom: std::marker::PhantomData,",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::Add<usize> for ModInt<M> {",
      "    type Output = ModInt<M>;",
      "    fn add(self, other: usize) -> Self::Output {",
      "        self + Self::from(other)",
      "    }",
      "}",
      "impl<M: Modulus + Copy> std::ops::AddAssign<usize> for ModInt<M> {",
      "    fn add_assign(&mut self, other: usize) {",
      "        *self = *self + Self::from(other);",
      "    }",
      "}"
    ]
  },
  "ModInt1000000007": {
    "prefix": "ModInt1000000007",
    "body": [
      "#[derive(Copy, Clone, Debug, Hash, Ord, PartialOrd, Eq, PartialEq)]",
      "struct ModInt1000000007;",
      "impl Modulus for ModInt1000000007 {",
      "    const VALUE: usize = 1_000_000_007;",
      "}"
    ]
  },
  "ModInt1000000009": {
    "prefix": "ModInt1000000009",
    "body": [
      "#[derive(Copy, Clone, Debug, Hash, Ord, PartialOrd, Eq, PartialEq)]",
      "struct ModInt1000000009;",
      "impl Modulus for ModInt1000000009 {",
      "    const VALUE: usize = 1_000_000_009;",
      "}"
    ]
  },
  "ModInt998244353": {
    "prefix": "ModInt998244353",
    "body": [
      "#[derive(Copy, Clone, Debug, Hash, Ord, PartialOrd, Eq, PartialEq)]",
      "struct ModInt998244353;",
      "impl Modulus for ModInt998244353 {",
      "    const VALUE: usize = 998_244_353;",
      "}"
    ]
  },
  "Modulus": {
    "prefix": "Modulus",
    "body": [
      "trait Modulus {",
      "    const VALUE: usize;",
      "}"
    ]
  },
  "MultiSet": {
    "prefix": "MultiSet",
    "body": [
      "struct MultiSet<T: Ord> {",
      "    counts: std::collections::BTreeMap<T, usize>,",
      "    len: usize,",
      "}",
      "impl<T: Ord> MultiSet<T> {",
      "    pub fn new() -> Self {",
      "        MultiSet {",
      "            counts: std::collections::BTreeMap::new(),",
      "            len: 0,",
      "        }",
      "    }",
      "    pub fn insert(&mut self, v: T) {",
      "        *self.counts.entry(v).or_insert(0) += 1;",
      "        self.len += 1;",
      "    }",
      "    pub fn remove(&mut self, v: T) {",
      "        if let Some(x) = self.counts.get_mut(&v) {",
      "            if *x == 1 {",
      "                self.counts.remove(&v);",
      "            } else {",
      "                *x -= 1;",
      "            }",
      "            self.len -= 1;",
      "        }",
      "    }",
      "    pub fn remove_all(&mut self, v: T) {",
      "        if let Some(x) = self.counts.get(&v) {",
      "            self.len -= x;",
      "        }",
      "        self.counts.remove(&v);",
      "    }",
      "    pub fn contains(&self, v: T) -> bool {",
      "        self.counts.contains_key(&v)",
      "    }",
      "    pub fn count(&self, v: T) -> usize {",
      "        self.counts.get(&v).copied().unwrap_or(0)",
      "    }",
      "    pub fn len(&self) -> usize {",
      "        self.len",
      "    }",
      "    pub fn is_empty(&self) -> bool {",
      "        self.len == 0",
      "    }",
      "    pub fn clear(&mut self) {",
      "        self.counts.clear();",
      "        self.len = 0;",
      "    }",
      "    pub fn iter(&self) -> impl Iterator<Item = &T> {",
      "        self.counts",
      "            .iter()",
      "            .flat_map(move |(value, count)| std::iter::repeat(value).take(*count))",
      "    }",
      "}"
    ]
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "fn sieve<T: FromIterator<usize>>(n: usize) -> T {",
      "    let mut is_prime = vec![true; n + 1];",
      "    for num in 2..=(n as f64).sqrt() as usize {",
      "        if is_prime[num] {",
      "            is_prime[num * num..]",
      "                .iter_mut()",
      "                .step_by(num)",
      "                .for_each(|prime| *prime = false);",
      "        }",
      "    }",
      "    (1..n).filter(|&x| is_prime[x]).collect()",
      "}"
    ]
  }
}
