local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets("cpp", {
	s("maxflow", {
		t({
			"",
			"// Function to perform BFS and find an augmenting path",
			"bool bfs(vector<vector<int>>& capacity, vector<vector<int>>& adj, vector<int>& parent, int source, int sink) {",
			"    int n = capacity.size();",
			"    vector<bool> visited(n, false);",
			"    queue<int> q;",
			"    q.push(source);",
			"    visited[source] = true;",
			"    parent[source] = -1;",
			"",
			"    while (!q.empty()) {",
			"        int u = q.front(); q.pop();",
			"",
			"        for (int v : adj[u]) {",
			"            if (!visited[v] && capacity[u][v] > 0) {",
			"                parent[v] = u;",
			"                visited[v] = true;",
			"                if (v == sink) return true;",
			"                q.push(v);",
			"            }",
			"        }",
			"    }",
			"    return false;",
			"}",
			"",
			"// Edmonds-Karp implementation for Maximum Flow",
			"int maxFlow(vector<vector<int>>& capacity, vector<vector<int>>& adj, int source, int sink) {",
			"    int n = capacity.size();",
			"    vector<int> parent(n);",
			"    int max_flow = 0;",
			"",
			"    while (bfs(capacity, adj, parent, source, sink)) {",
			"        int path_flow = INT_MAX;",
			"",
			"        // Find the maximum flow in the found augmenting path",
			"        for (int v = sink; v != source; v = parent[v]) {",
			"            int u = parent[v];",
			"            path_flow = min(path_flow, capacity[u][v]);",
			"        }",
			"",
			"        // Update the capacities and reverse flows",
			"        for (int v = sink; v != source; v = parent[v]) {",
			"            int u = parent[v];",
			"            capacity[u][v] -= path_flow;",
			"            capacity[v][u] += path_flow;",
			"        }",
			"",
			"        max_flow += path_flow;",
			"    }",
			"",
			"    return max_flow;",
			"}",
		}),
	}),
})
